\documentclass[english,a4paper,12pt]{report}
\usepackage{fancyhdr}
\usepackage{comment}
\usepackage{iftex}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{enumerate}
\usepackage{tabularx}
\usepackage{amsfonts}
\usepackage{blindtext}
\usepackage{qtree}
\usepackage{multicol}
\usepackage{amsmath,bm}
\usepackage{float}
\usepackage{amssymb}
\usepackage{wrapfig}
\restylefloat{figure}
\newcommand{\tabitem}{~~\llap{\textbullet}~~}
\usepackage{minted}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
% \lstset{
%  basicstyle=\footnotesize,
%  language={[Objective]Caml},
%  breaklines=true,
%  tabsize=2,
%  frame=single,
%  numbers=left,
%  title=\lstname,
%  commentstyle=\color{mygreen},
%  numberstyle=\small\color{mygray},
%  stringstyle=\color{mymauve},
%  showstringspaces=false,
%  rulecolor=\color{black}
% }

\usepackage{xcolor}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
%Code listing style named "mystyle"

\usepackage{color}
\usepackage[draft=false]{hyperref}
\hypersetup{
    colorlinks=true, % make the links colored
    linkcolor=blue, % color TOC links in blue
    urlcolor=blue, % color URLs in blue
    linktoc=all % 'all' will create links for everything in the TOC
}
    
\urlstyle{same}
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour},   commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,     
  upquote=true,
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}


%"mystyle" code listing set
\lstset{style=mystyle}
\geometry{verbose,tmargin=4cm,bmargin=4cm,lmargin=1.5cm,rmargin=1cm,headheight=2.7cm,headsep=1cm,footskip=2cm}
\usepackage{array}
%
\def \hsp {\hspace{3mm}}
%
\makeatletter
\providecommand{\tabularnewline}{\\}
\makeatother
%
\ifxetex
\usepackage[T1]{fontenc}
\usepackage{fontspec}
\newfontfamily\nakulafont[AutoFakeBold=2]{Nakula}
\newfontfamily\liberationfont{Liberation Sans Narrow}
\newfontfamily\liberationsansfont{Liberation Sans}
\fi
%
\usepackage{tikz}
\usepackage{xcolor}
%
% 
\definecolor{circleorange}{rgb}{1,0.17,0.08}
\definecolor{darkorange}{rgb}{1,0.27,0.1}
\definecolor{orange2}{rgb}{1,0.5,0.15}
\definecolor{orange3}{rgb}{1,0.65,0.25}
\definecolor{yellow1}{rgb}{0.95,0.77,0.2}
\newcommand{\Omit}[1]{}
\fancypagestyle{plain}{
  \fancyhead[LO]
  {
\textbf{Compilers-II} \newline 
\textbf {IIT Hyderabad Computer Science \newline
Professor: Ramakrishna Upadrasta \newline
Final Report \newline
GrAlgo}
	  }
	  
%
	  \fancyhf[ROH]{
\begin{tikzpicture}[scale=0.25,every node/.style={transform shape}]
\draw [fill=circleorange,circleorange] (5,10) circle (1.15); 
\fill [darkorange] (5.06,8) -- (5.06,2) -- (7.3,1.2) -- (7.3,8.8) -- (5.06,8);
\fill [darkorange] (4.94,8) -- (4.94,2) -- (2.7,1.2) -- (2.7,8.8) -- (4.94,8);
\fill [orange2]    (7.4,8.4) -- (7.4,1.6) -- (8.2,1.2) -- (8.2,8.8) -- (7.4,8.4);
\fill [orange2]    (2.6,8.4) -- (2.6,1.6) -- (1.8,1.2) -- (1.8,8.8) -- (2.6,8.4);
\fill [orange3]    (8.3,8.4) -- (8.3,1.6) -- (9.0,1.2) -- (9.0,8.8) -- (8.3,8.4);
\fill [orange3]    (1.7,8.4) -- (1.7,1.6) -- (1.0,1.2) -- (1.0,8.8) -- (1.7,8.4);
\fill [yellow1]    (9.1,8.4) -- (9.1,1.6) -- (9.7,1.2) -- (9.7,8.8) -- (9.1,8.4);
\fill [yellow1]    (0.9,8.4) -- (0.9,1.6) -- (0.3,1.2) -- (0.3,8.8) -- (0.9,8.4);
\ifxetex
\node [scale=2.1] at (5,-0.1)  {   {\bf {\nakulafont  भारतीय प्रौद्योगिकी संस्थान हैदराबाद }} };
\node [scale=1.8] at (5,-1.2) {   {\bf {\liberationsansfont Indian Institute of Technology Hyderabad}} };
\fi
\end{tikzpicture}
		  }
%
\renewcommand\headrule
 {
\begin{tikzpicture}
\definecolor{yellow1}{rgb}{0.95,0.77,0.2}
\draw[line width=0.75mm, yellow1] (0,0) -- (\textwidth,0);
\end{tikzpicture} 
 }}
 \pagestyle{plain}


\title{\textbf{\underline{\Huge{GrAlgo}}}\\~\\
\textbf{Final Report}\\~\\
\textbf{Team 5}\\
}
\author{\textbf{Sahil Chandra} - \textbf{Project Manager} - CS20BTECH11033 
\\~\\  \textbf{P Ganesh Nikhil Madhav} - \textbf{System Architect} - CS20BTECH11036 
\\~\\ \textbf{Gorantla Pranav Sai} - \textbf{System Integrator} - CS20BTECH11018 \\~\\
\textbf{Suraj Telugu} - \textbf{Language Guru} - CS20BTECH11050  \\~\\
\textbf{Umesh Kalvakuntla} - \textbf{System Architect} - CS20BTECH11024   \\~\\
\textbf{Vanga Aravind Shounik} -  \textbf{Tester} - CS20BTECH11055 
\\~\\ \textbf{Adepu Vasisht} - \textbf{Tester} - CS20BTECH11002
}

\usepackage{titlesec}
% CODE STYLE
\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.97254902,0.97254902,1.0}
\definecolor{keyword}{rgb}{0.5,0,0.5}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{keyword},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=none,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C,
    morekeywords={string,small,large, bool, NULL,func,graph,dgraph,node,node_set,edge_set,edge_seq,nodes,levels,neighbours,BFS,DFS,print}
}
\begin{document}
\titleformat{\chapter}[display]   
{\normalfont\huge\bfseries}{}{0pt}{\Huge}
\titlespacing*{\chapter}{0pt}{-30pt}{25pt}
\maketitle

\tableofcontents
  
\chapter{Introduction}
With GrAlgo we aim to bring the user closer to the Graph Data Structure which is not available in the general STL library for C++. Since our language is built on helping the user to use the power of graphs without writing any of his own functions which saves time, we have used syntax which is close to C++ i.e like C++ we also write the main part of our code which is to be executed in the main function call. If the user wants to write custom functions he can do so like C++ which needs the return type to be mentioned. Our programming language intuitively uses inbuilt functions and inbuilt data types which makes GrAlgo a powerful tool. Using our language the user can easily define different types of graphs and also traverse using  Breadth-First and Depth-First methods using our inbuilt functions we also provide a wide range of methods to represent graphs such as “Node List”, “Edge List” along with the normal usage.

While the main USP of GrAlgo is the graph data structure provided and the functions which we implement upon them, the user can also use GrAlgo like a general programming language making it versatile for general usage as well.

\section{Uses}
\begin{itemize}
    \item Since C/Cpp does not have a dedicated library for graphs we have created a dsl solely for the usage of graphs.
    \begin{itemize}
        \item Using a new data type named ‘graphs’ to represent graphs.
        \item We are trying to implement 4 types of commonly used graphs and they are, Directed Graphs, Undirected Graphs, Weighted Graphs, and Unweighted Graphs.
        \item Common kinds of graph traversals like DFS and BFS are inbuilt functions provided to user. We return a sequence of nodes in these traversal algorithms.
        \item In real life graphs have to be used in different scenarios so our 
        language provides an interface exclusively for graphs to tackle these problems

    \end{itemize}
\end{itemize}

\chapter{Language Tutorial}
\section{Getting Started}
Lets get started with GrAlgo our language, user needs to have basic knowledge on C language and concepts
of graphs. Graphs are used to solve many real life problems but contemporary languages does not provide 
graph specified interfaces. Our language provides a graph oriented interface with a graph type so that
user gets a better experience in using graph algorithms. User has to have command on graphs and where to 
use them. Our program helps user in solving the real life programs involving graphs and variety of algorithms 
of graphs can be implemented more easily using our compiler. Further we provide basic tutorial of GrAlgo.
% \addcontentsline{toc}{chapter}{Introduction}

\section{Basic Program Structure}
We have a main function with int return type. All the variables are strongly typed and we have a
semi colon (;) at end of each line. Basic int, float, char, string data types are used.
graph datatype is created which stores a list of edges during initialization
and each edge is int a, int b pair data structure which means the edge from a --> b.

    \begin{lstlisting}[style=CStyle] 
    int main()
    {
        graph G = { 
                    2:3, 
                    1:2,
                    3:1
                  }
        return 0;
    }
    \end{lstlisting}

\section{Variable Declaration}
Following are the syntaxes of declaring variables used in GrAlgo. We must explicitly 
declare the variable with its datatype before use. we can also assign value while
declaration. Multiple variables can be declared in a single line with same datatype
name by separating each identifier with ','

\begin{lstlisting}[style=CStyle]
int a , b , c; // variable declaration
float f = 5.5; //variable declaration with initialization
string s; char c; // string and char variables
dgraph g = { 
                1:2, 
                2:3
            } // graph declared with initialization
\end{lstlisting}

\section{Function Declaration}
The User can define his own functions similar to C and Cpp in which the return type needs to be mentioned. return type function name (function arguments) is the usual pattern for declaration. The code of function is written in curly braces. All 
the variables initialized in function are in function scope and cannot be used 
outside. Given below is a sum function defined with int, int arguments and int 
return type.

\begin{lstlisting}[style=CStyle]
int sum(int a, int b){
    return a + b;
}
\end{lstlisting}

\section{Compilation and Running}
To build the compiler, the prerequisite softwares are
\begin{itemize}
    \item Flex, Bison
    \item GCC, clang++
    \item LLVM-suite
    \item Make
\end{itemize}
The above softwares can be installed by the following commands in terminal
\begin{lstlisting}
$ sudo apt install build-essential

$ sudo apt-get install flex bison clang-format clang-tidy clang-tools clang clangd libc++-dev libc++1 libc++abi-dev libc++abi1 libclang-dev libclang1 liblldb-dev libllvm-ocaml-dev libomp-dev libomp5 lld lldb llvm-dev llvm-runtime llvm python3-clang
\end{lstlisting}
Now, to build the compiler and run an examle , we have to go to the Semantics\_and\_CodeGen directory and run the 
following commands in bash
\begin{lstlisting}
$ make
$ make test
$ ./a.out 
\end{lstlisting}

\chapter{Language Reference Manual}
\section{Lexical Conventions}
\subsection{Comments}
The comments in this language follow the general C comment syntax.
\begin{itemize}
    \item With the line ending comments starting with two forward slashes   
    \lstinline{// This is a valid comment}
    \item MultiLine comments are written in the following way \textbf{“/*  Matter */”}.
    \item Nested comments and comments between strings are not allowed
\end{itemize}
\begin{lstlisting}[style=CStyle]
// This is a comment
int a = 3; // This is also a comment
/* 
This is a multiline comment
*/
 string a = "Aravind /* This is not a comment*/ Shounik" // This is considered a comment
\end{lstlisting}
\subsection{Identifiers}
Identifiers in our language need to follow certain rules, and they are 
\begin{itemize}
    \item The identifier should start with a letter (both capital and small included) or an underscore.
    \item Then any of the following can be used 
    \begin{itemize}
        \item Another character.
        \item Another underscore.
        \item Digit
    \end{itemize}
    \item The regex for the identifier is given as follows \verb|[_a-zA-Z][_0-9a-zA-Z]*|.
    \item Keywords cannot be used as identifiers 
\end{itemize}
\section{Keywords}
The following are keywords in our language and cannot be used as identifers
\begin{lstlisting}[style=CStyle]
if          else        int        float      return 
for         while       string     char       break
continue    void        graph      dgraph     node
node_set    edge_set    edge_seq   BFS        DFS
neighbours  nodes       levels          
\end{lstlisting}
\subsection{Operators}
\subsubsection{Unary Operators}
\begin{center}
\renewcommand{\arraystretch}{1.5}%
\begin{tabular}{ |m{10em}|m{10em}|m{10em}|m{10em}| } 
\hline
Purpose & Symbol & Associativity & Valid Operands \\
\hline
Parentheses for grouping of operations & ( ) & left to right & int, float \\
\hline
Increment & \verb|++| & Right to Left & int, float \\
\hline
Decrement & \verb|--| & Right to Left & int, float \\
\hline
\end{tabular}
\end{center}
\textbf{Example:}
\begin{lstlisting}[style=CStyle]
int a = ++b;            // returns b added by 1
int a = --b;            // returns b substracted by 1
\end{lstlisting}
\subsubsection{Arthimetic Operators}
\begin{center}
\renewcommand{\arraystretch}{1.5}%
\begin{tabular}{ |m{10em}|m{10em}|m{10em}|m{10em}| } 
\hline
Purpose & Symbol & Associativity & Valid Operands \\
\hline
Modulo & \verb|%| & Left to Right & int, float \\
\hline
Multiplication & \verb|*| & Left to Right & int, float \\
\hline
Division & \verb|/| & Left to Right & int, float \\
\hline
Addition & \verb|+| & Left to Right & int, float, string \\
\hline
Subtraction & \verb|-| & Left to Right & int, float \\
\hline
\end{tabular}
\end{center}
\textbf{Example:}
\begin{lstlisting}[style=CStyle]
int a = 3 + 5;                  // adds 3 and 5 to 8
float c = a - 1.2;              // subtracts a and 1.2 an int to get 7.8
int b = 9*5 ;                   // multiplies 9 and 5 to get 45
int c = 8/3;                    // divides 8 by 3 and returns the quotient 2
int d = 8%3;                    // returns the remainder 2 when 8 is divided by 3 
int a = (3+5)*4 + 3             // returns 35 as '()' has more taken precedence
\end{lstlisting}
\subsubsection{Other Operators}
\begin{center}
\renewcommand{\arraystretch}{1.5}%
\begin{tabular}{ |m{10em}|m{10em}|m{10em}|m{10em}| } 
\hline
Purpose & Symbol & Associativity & Valid Operands \\
\hline
Relational Operators & \verb|<=|, \verb|<|, \verb|>=|, \verb|>| & left to right & all data types\\
% \hline
& \verb|==|, \verb|!=| &  &  \\
\hline
Bitwise Operators & \verb|&|, $|$, \verb|^|  & left to right & bool \\
\hline
Logical Operators & \verb|&&| $||$ & left to right & bool \\
\hline
Assignment operators & \verb|=|, \verb|+=|, \verb|-=|, \verb|*=|, \verb|/=| & right to left & wherever the
operator is valid\\
\hline

\end{tabular}
\end{center}
\textbf{Example:}
\begin{lstlisting}[style=CStyle]
//Relational operators
bool a = (3 < 5);               // returns true if 3 is less than 5
bool b = (17 <= 8);             // returns false as 17 is not less than or equal to 8
bool d = (4 == 4);              // return true as 4 is equal to 4
bool a = (2 > 1);               // return true as 2 is greater than 1
bool b = (4 >= 3);              // return true as 4 is greater than or equal to 3

// Logical Operators
bool a = (3<5)&&(4>2);          // returns AND of both the boolean expressions - true
bool b = (3>5)||(4<2);          // returns OR of both the boolean expressions - false     
// Bitwise operators
int a = 3&5;                    // returns the bitwise AND of both the operators - 1
int b = 3|5;                    // returns the bitwise OR of both the operators - 7
//Assignment operators
int a = 1;                      // Assigns the value of 1 to the variable
int a += 1;                     // This adds 1 to the value of a and assigns it again giving 2
int a *= 4;                     // Assigns (a=2)*4 to a
int a /= 2;                     // Assigns (a=8)/2 to a
\end{lstlisting}
\chapter{Project Plan}
\vspace{-0.5cm}
\begin{itemize}
    \item \textbf{Week 0} \begin{itemize}
        \item Discussed various ideas on languages came up with a
        creative idea which is  feasible
        \item Decided on the tools to be used, the structure of the compiler
        \item Finalised the roles of the team members
    \end{itemize}
    \item \textbf{Week 1 }\begin{itemize}
        \item Discussed various features of the language and their feasibility
        \item Then finalised the language and compiled the language specification
        document
        \item Decided the syntax of the language along with graph implementation 
        \item Studied through these reference papers thoroughly on graph DSLs
        1. Green marl 2. Ligra
        
    \end{itemize}

        \item\textbf{ Week 2 }\begin{itemize}
        \item  Changes in the syntax of the language
        \item Finding ambiguities in our grammar
        \item Designing the lexer
        \item Testing the lexer
    \end{itemize}

        \item\textbf{ Week 3}\begin{itemize}
        \item Considered ways in which lexer could be  written and decided on flex
        \item Finished writing 70\% of lexer using Flex
        \item Added more test cases for the lexer
    \end{itemize}

        \item \textbf{Week 4} \begin{itemize}
        \item  Made ppt and videos about the
        implementation of our lexer
        \item Fixed more bugs in Parser
        \item Studied and analysed c and cpp parsers 
    \end{itemize}
 
        \item \textbf{Week 5 }\begin{itemize}
        \item  Working on the parser, integrating it with  lexer
        \item Learnt how to use Bison for parsing
        \item Completed 30\% of the parser   
    \end{itemize}

        \item \textbf{Week 6} \begin{itemize}
        \item Completed Parser
        \item Studied \textbf{Generating AST in yacc from flex and bison - orielly}
        \item Working on generating AST        
    \end{itemize}

        \item\textbf{ Week 7 }\begin{itemize}
        \item Completed AST generation
        \item Exploring different methods to implement semantic phase
        \item  Explored features of attribute grammar
    \end{itemize}

        \item \textbf{Week 8} \begin{itemize}
        \item Created symbol table
        \item integrating symbol table with the parser and lexer
        \item  inspected semantic analysers of basic languages      
    \end{itemize}
    
        \item \textbf{Week 9 }\begin{itemize}
        \item Shifted from C in bison to CPP in bison
        \item Revised the lexer and parser (ver 2.0) in cpp 
        \item Implemented symbol table
        \item Working on AST
    \end{itemize}

        \item\textbf{ Week 10} \begin{itemize}
        \item Progressed with semantic analysis
        \item Worked on error displays and design principles
        \item Considered on using Constant folding optimization
    \end{itemize}

        \item\textbf{ Week 11} \begin{itemize}
        \item Integrated symbol table with ast
        \item Worked on type checking in semantic analysis
        \item Studied llvm's kaleidoscope manual for code generation  
    \end{itemize}

        \item\textbf{ Week 12} \begin{itemize}
        \item Added more on type checking in semantics
        \item Worked on code generation
        \item Explored LLVM documentation on the symbol table provided by LLVM 
    \end{itemize}
    
        \item\textbf{ Week 13} \begin{itemize}
        \item Discussions to implement data structures
        \item Worked on code generation for language specific features
    \end{itemize}

            \item\textbf{ Week 14} \begin{itemize}
        \item Completed Code Generation
        \item Made Final - Report and Presentation
        \item Made Demo Video and presentation videos
    \end{itemize}
\end{itemize}
